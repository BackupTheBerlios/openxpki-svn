## OpenXPKI::Crypto::Backend::OpenSSL::Config
## Written 2005 and 2006 by Julia Dubenskaya and Michael Bell for the OpenXPKI project
## (C) Copyright 2005-2006 by The OpenXPKI Project
## $Revision: 218 $
	
use strict;
use warnings;

package OpenXPKI::Crypto::Backend::OpenSSL::Config;

use OpenXPKI::Server::Context qw( CTX );

use OpenXPKI::Debug 'OpenXPKI::Crypto::Backend::OpenSSL::Config';
use OpenXPKI::Exception;
##! 0: "FIXME: why do we have no delete_tmpfile operation?"
##! 0: "FIXME: a missing delete_tmpfile is a security risk"
use OpenXPKI qw(write_file get_safe_tmpfile);
use OpenXPKI::DN;
use OpenXPKI::DateTime;
use Date::Parse;
use English;

sub new
{
    my $that = shift;
    my $class = ref($that) || $that;

    my $self = shift;
    bless $self, $class;

    ##! 1: "WARNING:FIXME: missing all checks for the initialization"

    return $self;
}

############################
##     Public setters     ##
############################

sub set_engine
{
    my $self = shift;
    $self->{ENGINE} = shift;
    return 1;
}

sub set_profile
{
    my $self = shift;
    $self->{PROFILE} = shift;
    return 1;
}

sub set_cert_list
{
    ##! 1: "start"
    my $self = shift;
    my $list = shift;
    $self->{INDEX_TXT} = "";

    foreach my $arrayref (@{$list})
    {
        ##! 4: "handle next certficate"

        # end of time_t datatype in C library
        my ($cert, $timestamp) = (undef, "2038:01:16T23:59:59.9999999");
        if (not ref $arrayref)
        {
            $cert      = $arrayref;
        } else {
            $cert      = $arrayref->[0];
            $timestamp = $arrayref->[1]
                if (scalar @{$arrayref} > 1);
        }

        ##! 4: "get X509 object"
        if (not ref($cert))
        {
            eval {
                ##! 1: "FIXME: where is the related free_object call?"
                ##! 1: "FIXME: this is a memory leak"
                $cert = $self->{XS}->get_object({DATA => $cert, TYPE => "X509"});
            };
            if (my $exc = OpenXPKI::Exception->caught())
            {
                OpenXPKI::Exception->throw (
                    message => "I18N_OPENXPKI_CRYPTO_OPENSSL_COMMAND_ISSUE_CRL_REVOKED_CERT_FAILED",
                    child   => $exc);
            } elsif ($EVAL_ERROR) {
                $EVAL_ERROR->rethrow();
            }
        }

        ##! 4: "create timestamp"
        $timestamp = str2time ($timestamp);
        $timestamp = [ gmtime ($timestamp) ];
        $timestamp = POSIX::strftime ("%y%m%d%H%M%S",@{$timestamp})."Z";
        ##! 4: "timestamp = $timestamp"

        ##! 4: "create start time - notbefore"
        my $start = $self->{XS}->get_object_function ({
                        OBJECT   => $cert,
                        FUNCTION => "notbefore"});
        $start = OpenXPKI::DateTime::convert_date(
                 {
                     DATE      => $start,
                     OUTFORMAT => 'openssltime',
                 });
        ##! 4: "OpenSSL notbefore date: $start"

        ##! 4: "create OpenSSL subject"
        my $subject = $self->{XS}->get_object_function ({
                          OBJECT   => $cert,
                          FUNCTION => "subject"});
        $subject = OpenXPKI::DN->new ($subject);
        $subject = $subject->get_openssl_dn ();

        ##! 4: "create serials"
        my $serial = $self->{XS}->get_object_function ({
                         OBJECT   => $cert,
                         FUNCTION => "serial"});
        $serial = Math::BigInt->new ($serial);
        my $hex = substr ($serial->as_hex(), 2);
        $hex    = "0".$hex if (length ($hex) % 2);

        ##! 4: "prepare index.txt entry"
        my $entry = "R\t$start\t$timestamp\t$hex\tunknown\t$subject\n";
        ##! 4: "LINE: $entry"
        $self->{INDEX_TXT} .= $entry;
    }
    ##! 1: "end"
    return 1;
}

################################
##     Dump configuration     ##
################################

sub dump
{
    ##! 1: "start"
    my $self = shift;
    my $config = "";

    ##! 2: "cleanup to make sure that we get a fresh config"
    $self->__cleanup_files();

    ##! 2: "dump common part"

    $config = "## OpenSSL configuration\n".
              "## dynamically generated by OpenXPKI::Crypto::Backend::OpenSSL::Config\n".
              "\n".
              "openssl_conf = openssl_init\n".
              "default_ca   = ca\n";

    $config .= $self->__get_openssl_common();
    $config .= $self->__get_oids();
    $config .= $self->__get_engine();
    if (exists $self->{PROFILE})
    {
        ##! 4: "write serial file (for CRL and certs)"

        my $serial = $self->{PROFILE}->get_serial();
        if (defined $serial)
        {
            $self->{FILENAME}->{SERIAL}   = $self->get_safe_tmpfile ({TMP => $self->{TMP}});
            ##! 8: "serial present"
            $serial = Math::BigInt->new ($serial);
            if (not defined $serial)
            {
                OpenXPKI::Exception->throw (
                    message => "I18N_OPENXPKI_CRYPTO_OPENSSL_CONFIG_DUMP_WRONG_SERIAL");
            }
            ##! 8: "serial accepted by Math::BigInt"
            my $hex = substr ($serial->as_hex(), 2);
            $hex = "0".$hex if (length ($hex) % 2);
            ##! 8: "hex serial is $hex"
            $self->write_file (FILENAME => $self->{FILENAME}->{SERIAL},
                               CONTENT  => $hex);
        }

        ##! 4: "write database files"

        ##! 4: "WARNING:FIXME: ATTR file of index.txt is not safe!"
        # ATTRFILE should be databasefile.attr
        # FIXME: we assume this file does not exist
        # FIXME: is this really safe? OpenSSL require it
        $self->{FILENAME}->{DATABASE} = $self->get_safe_tmpfile ({TMP => $self->{TMP}});
        $self->{FILENAME}->{ATTR} = $self->{FILENAME}->{DATABASE}.".attr";
        if (exists $self->{INDEX_TXT})
        {
            ##! 8: "INDEX_TXT present => this is a CRL"
            $self->write_file (FILENAME => $self->{FILENAME}->{DATABASE},
                               CONTENT  => $self->{INDEX_TXT});
        }
        else
        {
            ##! 8: "no INDEX_TXT => this is a certificate"
            $self->write_file (FILENAME => $self->{FILENAME}->{DATABASE},
                               CONTENT  => "");
        }
        $self->write_file (FILENAME => $self->{FILENAME}->{ATTR},
                           CONTENT  => "unique_subject = no\n");

        ##! 4: "PROFILE exists => CRL or cert generation"
        $config .= $self->__get_ca();
        $config .= $self->__get_extensions();
    
    }

    ##! 2: "write configuration file"

    $self->{FILENAME}->{CONFIG}   = $self->get_safe_tmpfile ({TMP => $self->{TMP}});
    $self->write_file (FILENAME => $self->{FILENAME}->{CONFIG},
                       CONTENT  => $config);

    ##! 2: "set the configuration to the XS library"
    ##! 2: "should we integrate this into the get_config function?"
    OpenXPKI::Crypto::Backend::OpenSSL::set_config ($self->{FILENAME}->{CONFIG});

    ##! 1: "start"
    return 1;
}

sub __get_openssl_common
{
    ##! 4: "start"
    my $self = shift;
    my $config = "\n[ openssl_init ]\n\n";

    ##! 8: "add the engine and OID section references"

    $config .= "engines = engine_section\n".
               "oid_section = new_oids\n";

    ## utf8 support options
    ## please do not touch or OpenXPKI's utf8 support breaks
    ## utf8=yes                # needed for correct issue of cert. This is
    ##                         # interchangeable with -utf8 "subj" command line modifier.
    ## string_mask=utf8only    # needed for correct issue of cert
    ## will be ignored today by "openssl req"
    ## name_opt = RFC2253,-esc_msb

    $config .= "\n[ req ]\n\n".
               "utf8              = yes\n".
               "string_mask       = utf8only\n".
               "distinguished_name = dn_policy\n";

    $config .= "\n[ dn_policy ]\n\n".
               "# this is a dummy because of preserve\n".
               "domainComponent = optional\n";


   ##! 4: "end"
   return $config;
}

sub __get_oids
{
    ##! 4: "today this is an empty function"
    my $self = shift;
    return "\n[ new_oids ]\n";
}

sub __get_engine
{
    ##! 4: "start"
    my $self = shift;
    my $config = "\n[ engine_section ]\n";

    $config .= "\n".
               $self->{ENGINE}->get_engine()." = engine_config\n".
               "\n".
               "[ engine_config ]\n".
               "\n".
               $self->{ENGINE}->get_engine_section();

    ##! 4: "end"
    return $config;
}

sub __get_ca
{
    ##! 4: "start"
    my $self = shift;

    my $config = "\n[ ca ]\n";

    $config .= "new_certs_dir     = ".$self->{TMP}."\n";
    $config .= "certificate       = ".$self->{ENGINE}->get_certfile()."\n";
    $config .= "private_key       = ".$self->{ENGINE}->get_keyfile."\n";

    if (my $notbefore = $self->{PROFILE}->get_notbefore()) {
	$config .= "default_startdate = " 
	    . OpenXPKI::DateTime::convert_date(
	    {
		OUTFORMAT => 'openssltime',
		DATE      => $notbefore,
	    })
	    . "\n";
    }
    
    if (my $notafter = $self->{PROFILE}->get_notafter()) {
	$config .= "default_enddate = " 
	    . OpenXPKI::DateTime::convert_date(
	    {
		OUTFORMAT => 'openssltime',
		DATE      => $notafter,
	    })
	    . "\n";
    }

    if (exists $self->{FILENAME}->{SERIAL})
    {
        $config .= "crlnumber         = ".$self->{FILENAME}->{SERIAL}."\n".
                   "serial            = ".$self->{FILENAME}->{SERIAL}."\n";
    }

    $config .= "default_md        = ".$self->{PROFILE}->get_digest()."\n".
               "database          = ".$self->{FILENAME}->{DATABASE}."\n".
               "default_crl_days  = ".$self->{PROFILE}->get_nextupdate_in_days()."\n".
               "x509_extensions   = v3ca\n".
               "preserve          = YES\n".
               "policy            = dn_policy\n".
               "name_opt          = RFC2253,-esc_msb\n".
               "utf8              = yes\n".
               "string_mask       = utf8only\n".
               "\n";

    ##! 4: "end"
    return $config;
}

sub __get_extensions
{
    ##! 4: "start"
    my $self = shift;

    my $config   = "\n[ v3ca ]\n";
    my $profile  = $self->{PROFILE};
    my $sections = "";
    
    foreach my $name (sort $profile->get_named_extensions())
    {
        my $critical = "";
        $critical = "critical," if ($profile->is_critical_extension ($name));
	
        if ($name eq "authority_info_access")
        {
            $config .= "authorityInfoAccess = $critical";
            foreach my $pair (@{$profile->get_extension("authority_info_access")})
            {
                my $type;
                $type = "caIssuers" if ($pair->[0] eq "CA_ISSUERS");
                $type = "OCSP"       if ($pair->[0] eq "OCSP");
                foreach my $http (@{$pair->[1]})
                {
                    $config .= "$type;URI:$http,";
                }
            }
            $config = substr ($config, 0, length ($config)-1); ## remove trailing ,
            $config .= "\n";
        }
        elsif ($name eq "authority_key_identifier")
        {
            $config .= "authorityKeyIdentifier = $critical";
            foreach my $param (@{$profile->get_extension("authority_key_identifier")})
            {
                $config .= "issuer:always," if ($param eq "issuer");
                $config .= "keyid:always,"  if ($param eq "keyid");
            }
            $config = substr ($config, 0, length ($config)-1); ## remove trailing ,
            $config .= "\n";
        }
        elsif ($name eq "basic_constraints")
        {
            $config .= "basicConstraints = $critical";
            foreach my $pair (@{$profile->get_extension("basic_constraints")})
            {
                if ($pair->[0] eq "CA")
                {
                    if ($pair->[1] eq "true")
                    {
                        $config .= "CA:true,";
                    } else {
                        $config .= "CA:false,";
                    }
                }
                if ($pair->[0] eq "PATH_LENGTH")
                {
                    $config .= "pathlen:".$pair->[1].",";
                }
            }
            $config = substr ($config, 0, length ($config)-1); ## remove trailing ,
            $config .= "\n";
        }
        elsif ($name eq "cdp")
        {
            $config .= "crlDistributionPoints = $critical\@cdp\n";
            $sections .= "\n[ cdp ]\n";
            my $i = 0;
            foreach my $cdp (@{$profile->get_extension("cdp")})
            {
                $sections .= "URI.$i=$cdp\n";
                $i++;
            }
            $sections .= "\n";
        }
        elsif ($name eq "extended_key_usage")
        {
            $config .= "extendedKeyUsage = $critical";
            my @bits = @{$profile->get_extension("extended_key_usage")};
            $config .= "clientAuth,"      if (grep /client_auth/,      @bits);
            $config .= "emailProtection," if (grep /email_protection/, @bits);
            my @oids = grep m{\.}, @bits;
            foreach my $oid (@oids)
            {
                $config .= "$oid,";
            }
            $config = substr ($config, 0, length ($config)-1); ## remove trailing ,
            $config .= "\n";
        }
        elsif ($name eq "issuer_alt_name")
        {
            $config .= "issuerAltName = $critical";
            my $issuer = join (",", @{$profile->get_extension("issuer_alt_name")});
            $config .= "issuer:copy" if ($issuer eq "copy");
            $config .= "\n";
        }
        elsif ($name eq "key_usage")
        {
            $config .= "keyUsage = $critical";
            my @bits = @{$profile->get_extension("key_usage")};
            $config .= "digitalSignature," if (grep /digital_signature/, @bits);
	    $config .= "nonRepudiation,"   if (grep /non_repudiation/,   @bits);
	    $config .= "keyEncipherment,"  if (grep /key_encipherment/,  @bits);
            $config .= "dataEncipherment," if (grep /data_encipherment/, @bits);
            $config .= "keyAgreement,"     if (grep /key_agreement/,     @bits);
            $config .= "keyCertSign,"      if (grep /key_cert_sign/,     @bits);
            $config .= "cRLSign,"          if (grep /crl_sign/,          @bits);
            $config .= "encipherOnly,"     if (grep /encipher_only/,     @bits);
            $config .= "decipherOnly,"     if (grep /decipher_only/,     @bits);
            $config = substr ($config, 0, length ($config)-1); ## remove trailing ,
            $config .= "\n";
        }
        elsif ($name eq "subject_alt_name")
        {
            $config .= "subjectAltName = $critical\@subject_alt_name\n";
            my $ref = $profile->get_extension("subject_alt_name");
            my $i   = 0;
            $sections .= "\n[ subject_alt_name ]\n";
            foreach my $pair (@{$ref})
            {
                ## the hash only includes one key/value pair
                $sections .= join (".", keys %{$pair}).".$i = ".
                             $pair->{join (".", keys %{$pair})}."\n";
                $i++;
            }
            $sections .= "\n";
        }
        elsif ($name eq "subject_key_identifier")
        {
            $config .= "subjectKeyIdentifier = $critical";
            my @bits = @{$profile->get_extension("subject_key_identifier")};
            $config .= "hash" if (grep /hash/, @bits);
            $config .= "\n";
        }
        elsif ($name eq "netscape/ca_cdp")
        {
            $config .= "nsCaRevocationUrl = $critical".
                       join ("", @{$profile->get_extension("netscape/ca_cdp")})."\n";
        }
        elsif ($name eq "netscape/cdp")
        {
            $config .= "nsRevocationUrl = $critical".
                       join ("", @{$profile->get_extension("netscape/cdp")})."\n";
        }
        elsif ($name eq "netscape/certificate_type")
        {
            $config .= "nsCertType = $critical";
            my @bits = @{$profile->get_extension("netscape/certificate_type")};
            $config .= "client,"  if (grep /ssl_client/, @bits);
            $config .= "objsign," if (grep /object_signing/, @bits);
            $config .= "email,"   if (grep /smime_client/, @bits);
            $config .= "sslCA,"   if (grep /ssl_client_ca/, @bits);
            $config .= "objCA,"   if (grep /object_signing_ca/, @bits);
            $config .= "emailCA," if (grep /smime_client_ca/, @bits);
            $config = substr ($config, 0, length ($config)-1); ## remove trailing ,
            $config .= "\n";
        }
        elsif ($name eq "netscape/comment")
        {
            $config .= "nsComment = $critical\"";
            my $string =  join ("", @{$profile->get_extension("netscape/comment")});
	    # FIXME: this inserts a literal \n - is this intended?
	    $string =~ s/\n/\\\\n/g;
            $config .= "$string\"\n";
        }
        else
        {
            OpenXPKI::Exception->throw (
                message => "I18N_OPENXPKI_CRYPTO_OPENSSL_COMMAND_WRITE_CONFIG_UNKNOWN_NAMED_EXTENSION",
                params  => {NAME => $name});
        }
    }
    $config .= "\n".$sections;
    ##! 16: "extensions ::= $config"

    ##! 4: "end"
    return $config;
}

sub get_config_filename
{
    my $self = shift;
    return $self->{FILENAME}->{CONFIG};
}

#####################
##     cleanup     ##
#####################

sub cleanup
{
    ##! 1: "start"
    my $self = shift;

    ##! 2: "delete profile"
    delete $self->{PROFILE} if (exists $self->{PROFILE});

    ##! 2: "delete index.txt database"
    delete $self->{INDEX_TXT} if (exists $self->{INDEX_TXT});

    ##! 2: "cleanup files"
    $self->__cleanup_files();

    ##! 1: "end"
    return 1;
}

sub __cleanup_files
{
    ##! 1: "start"
    my $self = shift;

    ##! 2: "return if no files must be deleted"
    return 1 if (not exists $self->{FILENAME} or
                 not scalar keys %{$self->{FILENAME}});

    ##! 2: "delete all temp files"
    foreach my $filename (sort keys %{$self->{FILENAME}})
    {
        ##! 4: "filename: $filename"
        unlink($filename);
    }
    delete $self->{FILENAME};

    ##! 1: "end"
    return 1;
}

sub DESTROY
{
    my $self = shift;
    $self->__cleanup_files();
}

1;
__END__

=head1 Description

This module was designed to create an OpenSSL configuration on the fly for
the various operations of OpenXPKI. The module support the following
different section types:

=item - general OpenSSL configuration

=item - engine configuration

=item - new OIDs

=item - CA configuration

=item - CRL extension configuration

=item - certificate extension configuration

=item - CRL distribution points

=item - subject alternative names

=head1 Functions

=over

=item - new

=item - set_engine

=item - set_profile

=item - set_index_list

=item - dump

=item - get_config_filename

=back

=head1 Example

my $profile = OpenXPKI::Crypto::Backend::OpenSSL::Config->new (
              {
                  TMP    => '/tmp',
              });
$profile->set_engine($engine);
$profile->set_profile($crl_profile);
$profile->set_index_list(@certlist);
$profile->dump();
my $conf = $profile->get_config_filename();
... execute an OpenSSL command with "-config $conf" ...
... or execute an OpenSSL command with "OPENSSL_CONF=$conf openssl" ...

=head1 See Also

OpenXPKI::Crypto::Profile::Base, OpenXPKI::Crypto::Profile::CRL,
OpenXPKI::Crypto::Profile::Certificate and OpenXPKI::Crypto::Backend::OpenSSL
